accuracy(holt2)[,'MASE']
accuracy(holt3)[,'MASE']
accuracy(airHWforecast)[,'MASE']
accuracy(autoexpaircast)[,'MASE']
accuracy(autoarimaaircast)[,'MASE']
ndiffs(airtimeseries)
pacf(airtimeseries)
Box.test(forecast.HoltWinters(airHWforecast, h=12)$residuals, lag=20, type="Ljung-Box")
acf(forecast.HoltWinters(airHWforecast, h=12)$residuals, lag.max=20)
Box.test(forecast.HoltWinters(airHWforecast, h=12)$residuals, lag=20, type="Ljung-Box")
pacf(forecast.HoltWinters(airHWforecast, h=12)$residuals, lag.max=20)
acf(forecast.HoltWinters(airHWforecast, h=12)$residuals, lag.max=20, main="ACF")
pacf(forecast.HoltWinters(airHWforecast, h=12)$residuals, lag.max=20,main="PACF")
acf(forecast.HoltWinters(airHWforecast, h=3)$residuals, lag.max=20, main="ACF")
acf(airtimeseries)
airHWforecast <- HoltWinters(logairtimeseries)
arima(airtimeseries)
arima(airtimeseries,order=c(0,1 ,0 ))
accuracy(arima(airtimeseries,order=c(0,1 ,0 )))
accuracy(arima(airtimeseries,order=c(0,1 ,1 )))
accuracy(arima(airtimeseries,order=c(1,1 ,1 )))
accuracy(arima(airtimeseries,order=c(0,0 ,0)))
accuracy(arima(airtimeseries,order=c(0,0 ,1)))
accuracy(arima(airtimeseries,order=c(1,0 ,1)))
accuracy(arima(airtimeseries,order=c(1,0 ,0)))
accuracy(arima(airtimeseries,order=c(1,1,0)))
airHWforecast <- HoltWinters(airtimeseries)
plot.forecast(forecast.HoltWinters(airHWforecast, h=12))
plot.ts(forecast.HoltWinters(airHWforecast, h=12)$residuals,main="Forecast Errors")
abline(h=log(MANE),col="red") #MANE from naive
exp(accuracy(airHWforecast))
plot(hwairforecast)
hwairforecast
hwairfcast <- HoltWinters(airtimeseries)
hwairfcast
plot(hwairfcast)
plot(hwairfcast)
hwairfcast <- HoltWinters(airtimeseries)
plot(hwairfcast)
plot.forecast(forecast.HoltWinters(airHWforecast, h=12))
?HoltWinters
hwairfcast <- HoltWinters(airtimeseries,h=12)
hwairfcast <- forecast.HoltWinters(airtimeseries,h12)
forecast.HoltWinters(airHWforecast, h=12)
hwairfcast <- forecast.HoltWinters(airHWforecast, h=12)
plot(hwairfcast)
plot(hwairfcast$residuals,main="Forecast Errors")
abline(h=log(MANE),col="red") #MANE from naive
abline(h=MANE,col="red") #MANE from naive
plot(airHWforecast$fitted )
plot(hwairfcast$fitted )
airHWforecast
exp(accuracy(hwairfcast))
hwairfcast <- forecast.HoltWinters(airHWforecast, h=12)
plot(hwairfcast)
plot(hwairfcast$residuals,main="Forecast Errors")
abline(h=MANE,col="red") #MANE from naive
exp(accuracy(hwairfcast))
acf(forecast.HoltWinters(hwairfcast , h=12)$residuals, lag.max=20, main="ACF")
Box.test(forecast.HoltWinters(hwairfcast , h=12)$residuals, lag=20, type="Ljung-Box")
pacf(forecast.HoltWinters(hwairfcast , h=12)$residuals, lag.max=20,main="PACF")
accuracy(naiveairfcast)[,'MASE']
accuracy(meanairfcast)[,'MASE']
accuracy(rwfairfcast)[,'MASE']
accuracy(snaiveairfcast)[,'MASE']
accuracy(exponairfcast)[,'MASE']
accuracy(holt1)[,'MASE']
accuracy(holt2)[,'MASE']
accuracy(holt3)[,'MASE']
accuracy(hwairfcast)[,'MASE']
accuracy(autoexpaircast)[,'MASE']
accuracy(autoarimaaircast)[,'MASE']
seasonplot(airtimeseries,ylab="Number", xlab="Year",
main="Seasonal plot: Air Travel",
year.labels=TRUE, year.labels.left=TRUE, col=1:20, pch=19)
monthplot(airtimeseries,ylab="Number",xlab="Month",xaxt="n",
main="Seasonal deviation plot: Air travel")
axis(1,at=1:12,labels=month.abb,cex=0.8)
monthplot(logairtimeseries,ylab="Number",xlab="Month",xaxt="n",
main="Seasonal deviation plot: Log Air travel")
axis(1,at=1:12,labels=month.abb,cex=0.8)
monthplot(log(airtimeseries),ylab="Number",xlab="Month",xaxt="n",
main="Seasonal deviation plot: Log Air travel")
axis(1,at=1:12,labels=month.abb,cex=0.8)
seasonplot(log(airtimeseries),ylab="Number", xlab="Year",
main="Seasonal plot: Log Air Travel",
year.labels=TRUE, year.labels.left=TRUE, col=1:20, pch=19)
seasonplot(airtimeseries,ylab="Number", xlab="Year",
main="Seasonal plot: Air Travel",
year.labels=TRUE, year.labels.left=TRUE, col=1:20, pch=19)
plot(airtimeseries, ylab="Number", xlab="Year", main="Air Travel")
logairtimeseries <- log(airtimeseries)
plot(logairtimeseries, ylab="Number", xlab="Year", main="Log Air Travel")
n=8
airtimeseriesSMA <- SMA(airtimeseries,n=n)
plot.ts(airtimeseriesSMA, main="Air (Smoothed)")
n=12
airtimeseriesSMA <- SMA(airtimeseries,n=n)
plot.ts(airtimeseriesSMA, main="Air (Smoothed)")
n=6
airtimeseriesSMA <- SMA(airtimeseries,n=n)
plot.ts(airtimeseriesSMA, main="Air (Smoothed)")
airtimeseriescomponents <- decompose(airtimeseries)
plot(airtimeseriescomponents)
autoexpaircast<-ets(airtimeseries, h=12)
plot(forecast(autoarimaaircast), main="Forecast")
seasonplot(airtimeseries,ylab="Number", xlab="Year",
main="Seasonal plot: Air Travel",
year.labels=TRUE, year.labels.left=TRUE, col=1:20, pch=19)
seasonplot(log(airtimeseries),ylab="Number", xlab="Year",
main="Seasonal plot: Log Air Travel",
year.labels=TRUE, year.labels.left=TRUE, col=1:20, pch=19)
airtimeseriesarima <- arima(airtimeseries, order=c(0,1,1))
arimaairtimeseries <- arima(airtimeseries, order=c(0,1,1))
airtimeseriesforecasts <- forecast.Arima(airtimeseriesarima, h=12)
airtimeseriesforecasts
arimaairtimeseries <- arima(airtimeseries, order=c(0,0,1))
airtimeseriesforecasts <- forecast.Arima(airtimeseriesarima, h=12)
airtimeseriesforecasts
arimaairtimeseries <- arima(airtimeseries, order=c(0,1,0))
airtimeseriesforecasts <- forecast.Arima(airtimeseriesarima, h=12)
airtimeseriesforecasts
plot(airtimeseriesforecasts)
arimaairfcast<- forecast.Arima(airtimeseriesarima, h=12)
plot(aarimaairfcast)
plot(arimaairfcast)
plot(arimaairfcast$residuals,main="Forecast Errors")
abline(h=MANE,col="red") #MANE from naive
exp(accuracy(arimaairfcast))
accuracy(meanairfcast)[,'MASE']
accuracy(rwfairfcast)[,'MASE']
accuracy(snaiveairfcast)[,'MASE']
accuracy(exponairfcast)[,'MASE']
accuracy(holt1)[,'MASE']
accuracy(holt2)[,'MASE']
accuracy(holt3)[,'MASE']
accuracy(hwairfcast)[,'MASE']
accuracy(arimaairfcast)[,'MASE']
accuracy(autoexpaircast)[,'MASE']
accuracy(autoarimaaircast)[,'MASE']
hwairfcast <- forecast.HoltWinters(airtimeseries, h=12)
hwairfcast <- forecast.HoltWinters(airtimeseries, h=12)
#hwairfcast <- forecast.HoltWinters(airtimeseries, h=12)
airHWforecast <- HoltWinters(logairtimeseries)
hwairfcast <- forecast.HoltWinters(airHWforecast, h=12)
airHWforecast <- HoltWinters(airtimeseries)
hwairfcast <- forecast.HoltWinters(airHWforecast, h=12)
plot(hwairfcast)
arimaairtimeseries <- arima(airtimeseries, order=c(0,1,0))
arimaairfcast<- forecast.Arima(arimaairtimeseries, h=12)
plot(arimaairfcast)
plot(arimaairfcast$residuals,main="Forecast Errors")
abline(h=MANE,col="red") #MANE from naive
exp(accuracy(arimaairfcast))
data(LakeHuron)
fit<-arima(LakeHuron,order=c(1,0,1))
fit
accuracy(fit)
accuracy(arimaairfcast)
accuracy(arimaairfcast,arimaairtimeseries)
accuracy(arimaairfcast)
tsdiag(fit)
tsdiag(arimaairfcast)
tsdiag(arimaairtimeseries)
tsdiag(autoexpaircast)
tsdiag(autoarimaaircast)
accuracy(hwairfcast)
tsdiag(airHWforecast)
tsdiag(hwairfcast)
lag(airtimeseries,1)
?lag
diff(airtimeseries)
fit <- Arima(airtimeseries, order=c(0,1,1), seasonal=c(0,1,1))
fir
fit
accuracy(fit)
fit <- Arima(airtimeseries, order=c(1,1,1), seasonal=c(1,1,1))
accuracy(fit)
# Clear the environment
rm(list=ls())
# Turn off scientific notations for numbers
options(scipen = 999)
# Set locale
Sys.setlocale("LC_ALL", "English")
# Set seed for reproducibility
set.seed(2345)
# Load the libraries
library(psych)
library(e1071)
library(caret)
library(fBasics)
# Load the data
df<-read.csv(file.choose())
#df <-read.csv("d:/data/diabetes.csv")
colSums(!is.na(df))
names(df) <-tolower(names(df))
names(df) <- gsub("\\(","",names(df))
names(df) <- gsub("\\)","",names(df))
names(df) <- gsub("\\.","",names(df))
names(df) <- gsub("_","",names(df))
names(df) <- gsub("-","",names(df))
names(df) <- gsub(",","",names(df))
df$policynumber <-NULL
# do the random split (25% held out for test), put the label back into the data frame
df$istest <- runif(nrow(df))<0.25
df$datalabel <- ifelse(df$istest,"test data","train data")
dftrain = df[!df$istest,]
dftest = df[df$istest,]
# remove unneeded columns
cols<-c("istest","datalabel")
dftrain<-dftrain[,!names(dftrain) %in% cols]
dftest<-dftest[,!names(dftest) %in% cols]
rm(df,splitIndex,test,train,cols)
dftrain$loglosses<-log(dftrain$losses)
dftest$loglosses<-log(dftest$losses)
attach(dftrain)
str(dftrain)
summary(dftrain)
basicStats(dftrain) #Computed basic stats
colStats(dftrain)
colMeans(dftrain) # Computes sample mean by col
describe(dftrain$age, type=1)
describeBy(dftrain$age,dftrain$gender, type=1)
describeBy(dftrain$age,dftrain$married, type=1)
hc <- hclust(dist(dftrain))   # apply hirarchical clustering
plot(hc)                      # Print Dendrogram
nbr=3
di <- dist(dftrain, method="euclidean")
tree <- hclust(di, method="ward.D2")
dftrain$hcluster <- as.factor((cutree(tree, k=nbr)-2) %% 3 +1)
detach(dftrain)
attach(dftrain)
plot(tree, xlab="")
rect.hclust(tree, k=nbr, border="red")
aggregate(dftrain, by=list(hcluster),FUN=mean, na.rm=TRUE)
column <- gender
with(dftrain, table(hcluster, column))
barplot(with(dftrain, table(hcluster, column)),col=c("red","green","blue"),beside = TRUE)
column <- fueltype
with(dftrain, table(hcluster, column))
barplot(with(dftrain, table(hcluster, column)),col=c("red","green","blue"),beside = TRUE)
column <- married
with(dftrain, table(hcluster, column))
barplot(with(dftrain, table(hcluster, column)),col=c("red","green","blue"),beside = TRUE)
mean(dftrain$age,na.rm=TRUE)
median(dftrain$age,na.rm=TRUE)
geometric.mean(dftrain$age,na.rm=TRUE) #not useful if zero in data
harmonic.mean(dftrain$age,na.rm=TRUE)
library(rpart)
fit <- rpart(hcluster ~ ., method="class", data=dftrain)
printcp(fit) # display the results
plotcp(fit) # visualize cross-validation results
summary(fit) # detailed summary of splits
# plot tree
text(fit, use.n=TRUE, all=TRUE, cex=.8)
plot(fit, uniform=TRUE, main="Classification Tree ")
text(fit, use.n=TRUE, all=TRUE, cex=.8)
pfit<- prune(fit, cp=   fit$cptable[which.min(fit$cptable[,"xerror"]),"CP"])
# plot the pruned tree
plot(pfit, uniform=TRUE,   main="Pruned Classification Tree")
text(pfit, use.n=TRUE, all=TRUE, cex=.8)
post(pfit, file = "c:/ptree.ps", title = "Pruned Classification Tree")
fit <- rpart(hcluster ~ .,method="anova", data=dftrain)
printcp(fit) # display the results
plotcp(fit) # visualize cross-validation results
summary(fit) # detailed summary of splits
rsq.rpart(fit) # visualize cross-validation results
# plot tree
plot(fit, uniform=TRUE, main="Regression Tree")
text(fit, use.n=TRUE, all=TRUE, cex=.8)
library(randomForest)
fit <- randomForest(as.factor(diabetes) ~ .,   data=dftrain)
print(fit) # view results
importance(fit) # importance of each predictor
varImpPlot(fit)
plot(fit)
varImpPlot(fit)
# Random Forest prediction
library(randomForest)
fit <- randomForest(as.factor(hckuster) ~ .,   data=dftrain)
print(fit) # view results
importance(fit) # importance of each predictor
varImpPlot(fit)
plot(fit)
fit <- randomForest(as.factor(hcluster) ~ .,   data=dftrain)
print(fit) # view results
varImpPlot(fit)
plot(fit)
par(mfrow=c(1,2))
seasonplot(airtimeseries,ylab="Number", xlab="Year",
main="Seasonal plot: Air Travel",
year.labels=TRUE, year.labels.left=TRUE, col=1:20, pch=19)
seasonplot(log(airtimeseries),ylab="Number", xlab="Year",
main="Seasonal plot: Log Air Travel",
year.labels=TRUE, year.labels.left=TRUE, col=1:20, pch=19)
# Clear the environment
rm(list=ls())
# Turn off scientific notations for numbers
options(scipen = 999)
options(digits=8)
# Set locale
Sys.setlocale("LC_ALL", "English")
# Set seed for reproducibility
set.seed(2345)
# load the libraries
library(forecast)
library(TTR)
library(fpp)
# Load the data and make it into time series
air <- scan("D:/Data/911air.txt")
airtimeseries <- ts(air, frequency=12, start=c(1990,1))
#air <- scan("D:/Data/SampleTimeSeries.txt")
#airtimeseries <- ts(air, frequency=12, start=c(2010,1))
plot.ts(airtimeseries, main="Air")
```
plot.ts(airtimeseries, main="Air")
seasonplot(airtimeseries,ylab="Number", xlab="Year",
main="Seasonal plot: Air Travel",
year.labels=TRUE, year.labels.left=TRUE, col=1:20, pch=19)
seasonplot(log(airtimeseries),ylab="Number", xlab="Year",
main="Seasonal plot: Log Air Travel",
year.labels=TRUE, year.labels.left=TRUE, col=1:20, pch=19)
monthplot(airtimeseries,ylab="Number",xlab="Month",xaxt="n",
main="Seasonal deviation plot: Air travel")
axis(1,at=1:12,labels=month.abb,cex=0.8)
monthplot(log(airtimeseries),ylab="Number",xlab="Month",xaxt="n",
main="Seasonal deviation plot: Log Air travel")
axis(1,at=1:12,labels=month.abb,cex=0.8)
plot.ts(airtimeseriesSMA, main="Air (Smoothed)")
n=6
airtimeseriesSMA <- SMA(airtimeseries,n=n)
plot.ts(airtimeseriesSMA, main="Air (Smoothed)")
airtimeseriescomponents <- decompose(airtimeseries)
plot(airtimeseriescomponents)
naiveairfcast <- naive(airtimeseries,12)
plot(naiveairfcast,main="Forecast")
plot(naiveairfcast$residuals, main="Forecast Errors")
MANE <-accuracy(naiveairfcast)[,'MAE']
abline(h=MANE,col="red")
accuracy(naiveairfcast)
source.with.encoding('~/.active-rstudio-document', encoding='UTF-8', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
logLik(fit) ##-168.724
prediction<-predict(fit, dftest, type="response") # predicted values
residuals(fit, type="deviance") # residuals
fit<-glm(f1,data=dftrain,family=binomial)
summary(fit) # display results
confint(fit) # 95% CI for the coefficients using profiled log-likelihood
confint.default(fit) # 95% CI for the coefficients using standard errors
exp(coef(fit)) # exponentiated coefficients a.k.a odds ratios
exp(confint(fit)) # 95% CI for exponentiated coefficients
exp(cbind(OR = coef(fit), confint(fit))) ## odds ratios and 95% CI together
d<-anova(fit,test='Chisq') # or d<-anova(fit,test='LRT')
source('~/.active-rstudio-document', echo=TRUE)
library(qcc)
library(SixSigma)
source('~/.active-rstudio-document', echo=TRUE)
eruption.lm = lm(eruptions ~ waiting, data=faithful)
summary(eruption.lm)
coeffs = coefficients(eruption.lm)
coeffs
newdata = data.frame(waiting=80)
predict(eruption.lm, newdata)
predict(eruption.lm, newdata, interval="confidence")
predict(eruption.lm, newdata, interval="predict")
data(mtcars)
str(mtcars)
cor(mtcars)
cor.out <- sort(cor(mtcars)[,1])
round(cor.out, 3)
basemodel <- lm(mpg ~ am, data = mtcars)
summary(basemodel)
inclusivemodel <- lm(mpg ~ ., data = mtcars)
summary(inclusivemodel)
bestmodel <- step(inclusivemodel, direction = "both")
summary(bestmodel)
anova(basemodel, bestmodel)
coefficients(bestmodel) # model coefficients
confint(bestmodel, level=0.95) # CIs for model parameters
fitted(bestmodel) # predicted values
anova(bestmodel) # anova table
vcov(bestmodel) # covariance matrix for model parameters
data(mtcars)
str(mtcars)
```
```{r}
mtcars$gear <- factor(mtcars$gear,levels=c(3,4,5),labels=c("3gears","4gears","5gears"))
mtcars$cyl <- factor(mtcars$cyl,levels=c(4,6,8),labels=c("4cyl","6cyl","8cyl"))
mtcars$am <- factor(mtcars$am,levels=c(0,1),labels=c("Automatic","Manual"))
mtcars$vs <- factor(mtcars$vs)
mtcars$carb <- factor(mtcars$carb)
cor.out <- sort(cor(mtcars)[,1])
round(cor.out, 3)
cor(mtcars)
cor.out <- sort(cor(mtcars)[,1])
data(mtcars)
str(mtcars)
```
cor(mtcars)
cor.out <- sort(cor(mtcars)[,1])
round(cor.out, 3)
basemodel <- lm(mpg ~ am, data = mtcars)
summary(basemodel)
basemodel <- lm(mpg ~ am, data = mtcars)
summary(basemodel)
coefficients(basemodel) # model coefficients
confint(basemodel, level=0.95) # CIs for model parameters
fitted(basemodel) # predicted values
anova(basemodel) # anova table
vcov(basemodel) # covariance matrix for model parameters
mtcars$gear <- factor(mtcars$gear,levels=c(3,4,5),labels=c("3gears","4gears","5gears"))
mtcars$cyl <- factor(mtcars$cyl,levels=c(4,6,8),labels=c("4cyl","6cyl","8cyl"))
mtcars$am <- factor(mtcars$am,levels=c(0,1),labels=c("Automatic","Manual"))
mtcars$vs <- factor(mtcars$vs)
mtcars$carb <- factor(mtcars$carb)
basemodel <- lm(mpg ~ am, data = mtcars)
summary(basemodel)
coefficients(basemodel) # model coefficients
confint(basemodel, level=0.95) # CIs for model parameters
fitted(basemodel) # predicted values
anova(basemodel) # anova table
vcov(basemodel) # covariance matrix for model parameters
```
source('~/.active-rstudio-document', echo=TRUE)
inclusivemodel <- lm(mpg ~ ., data = mtcars)
summary(inclusivemodel)
coefficients(inclusivemodel) # model coefficients
confint(inclusivemodel, level=0.95) # CIs for model parameters
fitted(inclusivemodel) # predicted values
anova(inclusivemodel) # anova table
vcov(inclusivemodel) # covariance matrix for model parameters
anova(basemodel, inclusivemodel)
bestmodel <- step(inclusivemodel, direction = "both")
summary(bestmodel)
coefficients(bestmodel) # model coefficients
confint(bestmodel, level=0.95) # CIs for model parameters
fitted(bestmodel) # predicted values
anova(bestmodel) # anova table
vcov(bestmodel) # covariance matrix for model parameters
anova(basemodel, bestmodel)
## simple data plot
plot (sort(mtcars$mpg))
## histogram
hist(mtcars$mpg)
plot(density(mtcars$mpg,na.rm=TRUE))
boxplot(mpg~am,mtcars)
plot(mpg~wt,mtcars)
plot(resid(basemodel))
plot(resid(incusivemodel))
plot(resid(inclusivemodel))
plot(resid(bestmodel))
plot(resid(basemodel)~fitted(basemodel))
plot(resid(inclusivemodel)~fitted(inclusivemodel))
plot(resid(bestmodel)~fitted(bestmodel))
qqnorm(resid(basemodel))
qqline(resid(basemodel))
qqnorm(resid(inclusivemodel))
qqline(resid(inclusivemodel))
qqnorm(resid(bestmodel))
qqline(resid(bestmodel))
qqnorm(resid(bestmodel))
qqline(resid(bestmodel))
plot(basemodel)
plot(bestmodel)
###Global test of model assumptions
```{r}
require(gvlma)
gvmodel <- gvlma(bestmodel)
summary(gvmodel)
```
install.packages("gvlma")
require(gvlma)
gvmodel <- gvlma(bestmodel)
summary(gvmodel)
gvmodel <- gvlma(inclusivemodel)
summary(gvmodel)
gvmodel <- gvlma(basemodel)
summary(gvmodel)
```{r}
leverage <- hatvalues(bestmodel)
tail(sort(leverage),3)
```
influential <- dfbetas(bestmodel)
tail(sort(influential[,6]),3)
avPlots(bestmodel)
plot(bestmodel, which=4, cook.levels=cutoff)
cutoff <- 4/((nrow(mtcars)-length(bestmodel$coefficients)-2))
plot(bestmodel, which=4, cook.levels=cutoff)
influencePlot(bestmodel,id.method="identify", main="Influence Plot", sub="Circle size is proportial to Cook's Distance" )
vif(bestmodel) # variance inflation factors
require(car)
ncvTest(bestmodel)
spreadLevelPlot(bestmodel)
vif(bestmodel) # variance inflation factors
sqrt(vif(bestmodel)) > 2 # problem?
# component + residual plot
crPlots(bestmodel)
# Ceres plots
ceresPlots(bestmodel)
durbinWatsonTest(bestmodel)
tail(sort(hatvalues(bestmodel)),3)
tail(sort(hatvalues(basemodel)),3)
tail(sort(hatvalues(inclusivemodel)),3)
tail(sort(dfbetas(bestmodel)[,6]),3)
tail(sort(dfbetas(bestmodel)[,6]),3)
tail(sort(dfbetas(basemodel)[,6]),3)
tail(sort(dfbetas(inclusivemodel)[,6]),3)
dfbeats(basemodel)
dfbetas(basemodel)
dfbetas(bestmodel)
tail(sort(dfbetas(basemodel)[,1]),3)
hatvalues(bestmodel)
